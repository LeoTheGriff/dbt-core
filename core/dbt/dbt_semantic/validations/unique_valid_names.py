
from __future__ import annotations

import re
import enum
from abc import ABC
from typing import List, Tuple, Dict

from dbt.exceptions import DbtSemanticValidationError
from dbt.contracts.graph.nodes import Entity
from dbt.dbt_semantic.time import TimeGranularity
from dbt.dbt_semantic.object_utils import assert_values_exhausted
from dbt.dbt_semantic.references import ElementReference


@enum.unique
class MetricFlowReservedKeywords(enum.Enum):
    """Enumeration of reserved keywords with helper for accessing the reason they are reserved"""

    METRIC_TIME = "metric_time"
    MF_INTERNAL_UUID = "mf_internal_uuid"

    @staticmethod
    def get_reserved_reason(keyword: MetricFlowReservedKeywords) -> str:
        """Get the reason a given keyword is reserved. Guarantees an exhaustive switch"""
        if keyword is MetricFlowReservedKeywords.METRIC_TIME:
            return (
                "Used as the query input for creating time series metrics from measures with "
                "different time dimension names."
            )
        elif keyword is MetricFlowReservedKeywords.MF_INTERNAL_UUID:
            return "Used internally to reference a column that has a uuid generated by MetricFlow."
        else:
            assert_values_exhausted(keyword)


class UniqueAndValidNames(ABC):
    """Check that names are unique and valid.
    * Names of elements in data sources are unique / valid within the data source.
    * Names of data sources, dimension sets, metric sets, and materializations in the model are unique / valid.
    """

    NAME_REGEX = re.compile(r"\A[a-z][a-z0-9_]*[a-z0-9]\Z")

    @staticmethod
    def _check_valid_name(name: str) -> List[str]: #noqa: D
        validation_errors = []

        if not UniqueAndValidNames.NAME_REGEX.match(name):
            validation_errors.append(
                    f"names should only consist of lower case letters, numbers, "
                    f"and underscores. In addition, names should start with a lower case letter, and should not end "
                    f"with an underscore, and they must be at least 2 characters long.",
                )
        if name.upper() in TimeGranularity.list_names():
            validation_errors.append(
                    f"names cannot match reserved time granularity keywords "
                )
        if name.lower() in {reserved_name.value for reserved_name in MetricFlowReservedKeywords}:
            reason = MetricFlowReservedKeywords.get_reserved_reason(MetricFlowReservedKeywords(name.lower()))
            validation_errors.append(
                f"this name is reserved by MetricFlow. Reason: {reason}"
                )

        return validation_errors

    @staticmethod
    def _validate_entity_elements(entity: Entity):
        validation_errors=[]
        element_info_tuples: List[Tuple[ElementReference, str]] = []

        if entity.measures:
            for measure in entity.measures:
                element_info_tuples.append(
                    (
                        measure.reference,
                        "measure"
                    )
                )

        if entity.identifiers:
            for identifier in entity.identifiers:
                element_info_tuples.append(
                    (
                        identifier.reference,
                        "identifier"
                    )
                )

        if entity.dimensions:
            for dimension in entity.dimensions:
                element_info_tuples.append(
                    (
                        dimension.reference,
                        "dimension"
                    )
                )

        name_to_type: Dict[ElementReference, str] = {}
        for name, _type in element_info_tuples:
            if name.name in name_to_type:
                validation_errors.append(
                    f"can't use name `{name.name}` for a "
                    f"{_type} when it was already used for a {name_to_type[name.name]}",
                    )
            else:
                name_to_type[name.name] = _type


        for name, _ in element_info_tuples:
            validation_errors += UniqueAndValidNames._check_valid_name(name=name.name)

        if validation_errors:
            raise DbtSemanticValidationError(
                f"In entity `{entity.name}`: {', '.join(e for e in validation_errors)}"
            )


    @staticmethod
    def _validate_top_level_entities(manifest_entites):
        """Checks names of objects that are not nested."""
        object_info_tuples = []
        validation_errors=[]
        if manifest_entites:
            for entity in manifest_entites:
                object_info_tuples.append(
                    (
                        entity.name,
                        "entity"
                    )
                )

        name_to_type: Dict[str, str] = {}

        for name, type_ in object_info_tuples:
            if name in name_to_type:
                validation_errors.append(
                    f"Can't use name `{name}` for a {type_} when it was already used for a "
                    f"{name_to_type[name]}",
                    )
            else:
                name_to_type[name] = type_
        
        if validation_errors:
            raise DbtSemanticValidationError(
                f"Errors: {', '.join(e for e in validation_errors)}"
            )

    @staticmethod
    def _validate_entities(manifest_entities):
        UniqueAndValidNames._validate_top_level_entities(manifest_entites=manifest_entities)
        for entity in manifest_entities:
            UniqueAndValidNames._validate_entity_elements(entity=entity)